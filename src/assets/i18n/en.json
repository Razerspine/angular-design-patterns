{
  "creational": {
    "factory": {
      "title": "Factory Method",
      "description": "<b>Factory Method</b> â€” creational design pattern that defines a common interface for creating objects, allowing subclasses to decide which class to instantiate. Works with abstractions instead of concrete classes, simplifies extension and maintenance. <br><br>In the classical implementation, the pattern uses an <b>interface</b> that concrete classes implement. In this Angular example, we use an <b>abstract class</b> (<code>NotificationAbstract</code>) instead, because it allows us to define common properties (like <code>message</code>) and optionally provide shared methods while still enforcing a contract for subclasses.",
      "step1": "<b>Step 1: Create Notification Framework</b><br>Define <code>NotificationAbstract</code> as a base for all notifications, declaring common methods like <code>show()</code>.",
      "step2": "<b>Step 2: Develop SuccessNotification</b><br>Create <code>NotificationSuccess</code> class, extending <code>NotificationAbstract</code>, and implement <code>show()</code> for success messages.",
      "step3": "<b>Step 3: Develop ErrorNotification</b><br>Create <code>NotificationError</code> class, extending <code>NotificationAbstract</code>, and implement <code>show()</code> for error messages.",
      "step4": "<b>Step 4: Develop WarningNotification</b><br>Create <code>NotificationWarning</code> class, extending <code>NotificationAbstract</code>, and implement <code>show()</code> for warning messages.",
      "step5": "<b>Step 5: Create NotificationFactory Service</b><br>Encapsulate creation logic depending on notification type in <code>NotificationFactoryService</code>.",
      "step6": "<b>Step 6: Use Factory Pattern in Component</b><br>Demonstrate the Factory Method pattern in <code>FactoryPatternComponent</code>, working only with abstractions."
    },
    "abstractFactory": {
      "title": "Abstract Factory",
      "description": "Abstract Factory is a creational design pattern that provides an interface for creating families of related objects without specifying their concrete classes.",
      "step1": "Step 1: Define an abstract Button class declaring the render() method.",
      "step2": "Step 2: Define an abstract Checkbox class declaring the render() method.",
      "step3": "Step 3: Implement LightButton extending ButtonAbstract with its own render() method.",
      "step4": "Step 4: Implement LightCheckbox extending CheckboxAbstract with its own render() method.",
      "step5": "Step 5: Implement DarkButton extending ButtonAbstract with its own render() method.",
      "step6": "Step 6: Implement DarkCheckbox extending CheckboxAbstract with its own render() method.",
      "step7": "Step 7: Define ThemeFactoryAbstract declaring methods to create Button and Checkbox.",
      "step8": "Step 8: Implement LightFactory to produce LightButton and LightCheckbox.",
      "step9": "Step 9: Implement DarkFactory to produce DarkButton and DarkCheckbox.",
      "step10": "Step 10: Create AbstractFactoryService to provide a specific factory based on the selected theme.",
      "step11": "Step 11: Build AbstractFactoryComponent to demonstrate creating UI elements from Light or Dark factories."
    }
  }
}
