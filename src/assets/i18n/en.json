{
  "creational": {
    "factory": {
      "title": "Factory Method",
      "description": "<b>Factory Method</b> — creational design pattern that defines a common interface for creating objects, allowing subclasses to decide which class to instantiate. Works with abstractions instead of concrete classes, simplifies extension and maintenance. <br><br>In the classical implementation, the pattern uses an <b>interface</b> that concrete classes implement. In this Angular example, we use an <b>abstract class</b> (<code>NotificationAbstract</code>) instead, because it allows us to define common properties (like <code>message</code>) and optionally provide shared methods while still enforcing a contract for subclasses.",
      "step1": "<b>Step 1: Create Notification Framework</b><br>Define <code>NotificationAbstract</code> as a base for all notifications, declaring common methods like <code>show()</code>.",
      "step2": "<b>Step 2: Develop SuccessNotification</b><br>Create <code>NotificationSuccess</code> class, extending <code>NotificationAbstract</code>, and implement <code>show()</code> for success messages.",
      "step3": "<b>Step 3: Develop ErrorNotification</b><br>Create <code>NotificationError</code> class, extending <code>NotificationAbstract</code>, and implement <code>show()</code> for error messages.",
      "step4": "<b>Step 4: Develop WarningNotification</b><br>Create <code>NotificationWarning</code> class, extending <code>NotificationAbstract</code>, and implement <code>show()</code> for warning messages.",
      "step5": "<b>Step 5: Create NotificationFactory Service</b><br>Encapsulate creation logic depending on notification type in <code>NotificationFactoryService</code>.",
      "step6": "<b>Step 6: Use Factory Pattern in Component</b><br>Demonstrate the Factory Method pattern in <code>FactoryPatternComponent</code>, working only with abstractions."
    },
    "abstractFactory": {
      "title": "Abstract Factory",
      "description": "Abstract Factory is a <b>creational design pattern</b> that provides an interface for creating families of related objects without specifying their concrete classes.",
      "step1": "<b>Step 1: Define Abstract Button</b><br/>Create an abstract Button class declaring the render() method.",
      "step2": "<b>Step 2: Define Abstract Checkbox</b><br/>Create an abstract Checkbox class declaring the render() method.",
      "step3": "<b>Step 3: Implement LightButton</b><br/>Extend ButtonAbstract and implement the render() method for the light theme.",
      "step4": "<b>Step 4: Implement LightCheckbox</b><br/>Extend CheckboxAbstract and implement the render() method for the light theme.",
      "step5": "<b>Step 5: Implement DarkButton</b><br/>Extend ButtonAbstract and implement the render() method for the dark theme.",
      "step6": "<b>Step 6: Implement DarkCheckbox</b><br/>Extend CheckboxAbstract and implement the render() method for the dark theme.",
      "step7": "<b>Step 7: Define ThemeFactoryAbstract</b><br/>Declare methods to create Button and Checkbox.",
      "step8": "<b>Step 8: Implement LightFactory</b><br/>Produce LightButton and LightCheckbox.",
      "step9": "<b>Step 9: Implement DarkFactory</b><br/>Produce DarkButton and DarkCheckbox.",
      "step10": "<b>Step 10: Create AbstractFactoryService</b><br/>Provide a specific factory based on the selected theme.",
      "step11": "<b>Step 11: Build AbstractFactoryComponent</b><br/>Demonstrate creating UI elements from Light or Dark factories."
    },
    "builder": {
      "title": "Builder",
      "description": "<b>Builder</b> — creational design pattern that allows constructing complex objects step by step. Instead of passing all parameters into a constructor, Builder provides a fluent API for building objects gradually. <br><br>In classical implementations, Builder is often used for assembling objects like documents or configurations. In our Angular example, we use it to build a <b>UI card</b> step by step.",
      "step1": "<b>Step 1: Define Card Model</b><br>Create <code>Card</code> interface with optional properties: <code>title</code>, <code>description</code>, <code>image</code>, <code>button</code>.",
      "step2": "<b>Step 2: Define Abstract Builder</b><br>Create <code>CardBuilderAbstract</code> with methods for title, description, image, and button.",
      "step3": "<b>Step 3: Implement Concrete Builder</b><br>Implement <code>SimpleCardBuilder</code> that sets each property of the card.",
      "step4": "<b>Step 4: Add Director</b><br>Create <code>CardDirector</code> that builds a predefined card (e.g., product card).",
      "step5": "<b>Step 5: Use in Angular Component</b><br>Demonstrate card building in <code>BuilderPatternComponent</code>."
    },
    "prototype": {
      "title": "Prototype",
      "description": "<b>Prototype</b> — creational design pattern that lets you copy existing objects without making your code dependent on their concrete classes. It is especially useful when creating a new instance is costly or complex. <br><br>In this Angular example, we create and clone <b>user profiles</b> (Admin, Guest) using the <code>clone()</code> method.",
      "step1": "<b>Step 1: Define Prototype Base</b><br>Create <code>UserProfilePrototype</code> with the <code>clone()</code> method and common properties.",
      "step2": "<b>Step 2: Create AdminProfile</b><br>Extend <code>UserProfilePrototype</code> and implement the <code>clone()</code> method for admins.",
      "step3": "<b>Step 3: Create GuestProfile</b><br>Extend <code>UserProfilePrototype</code> and implement the <code>clone()</code> method for guests.",
      "step4": "<b>Step 4: Add Service</b><br>Use <code>UserProfileService</code> to create and clone profiles.",
      "step5": "<b>Step 5: Use in Component</b><br>Demonstrate creating and cloning profiles in <code>PrototypePatternComponent</code>."
    },
    "singleton": {
      "title": "Singleton",
      "description": "<b>Singleton</b> — creational design pattern that ensures a class has only one instance and provides a global point of access to it. <br><br>In this Angular example, we implement a <b>Logger</b> that keeps a single shared instance across the app.",
      "step1": "<b>Step 1: Create Singleton</b><br>Define <code>Logger</code> class with a private constructor and a static <code>getInstance()</code> method.",
      "step2": "<b>Step 2: Wrap with Service</b><br>Use <code>LoggerService</code> to interact with the singleton in Angular context.",
      "step3": "<b>Step 3: Use in Component</b><br>Demonstrate logging messages in <code>SingletonPatternComponent</code>, showing that all logs come from the same instance."
    }
  },
  "structural": {
    "adapter": {
      "title": "Adapter",
      "description": "<b>Adapter</b> — structural design pattern that allows incompatible interfaces to work together. In this Angular example, <code>LoggerAdapterService</code> makes a third-party logger (<code>ThirdPartyLogger</code>) compatible with our <code>Logger</code> interface.",
      "step1": "<b>Step 1: Define Target (Logger interface)</b><br>Create a <code>Logger</code> interface with <code>log()</code> and <code>error()</code> methods.",
      "step2": "<b>Step 2: Introduce Adaptee (ThirdPartyLogger)</b><br>Simulate a third-party logger with different method names (<code>writeInfo()</code>, <code>writeError()</code>).",
      "step3": "<b>Step 3: Implement Adapter (LoggerAdapterService)</b><br>Wrap <code>ThirdPartyLogger</code> so it conforms to <code>Logger</code> interface.",
      "step4": "<b>Step 4: Use Adapter in Component</b><br>Inject <code>LoggerAdapterService</code> into a component and log messages without depending on third-party API."
    }
  }
}
