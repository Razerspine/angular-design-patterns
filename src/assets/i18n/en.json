{
  "creational": {
    "factory": {
      "title": "Factory Method",
      "description": "<b>Factory Method</b> — creational design pattern that defines a common interface for creating objects, allowing subclasses to decide which class to instantiate. Works with abstractions instead of concrete classes, simplifies extension and maintenance. <br><br>In the classical implementation, the pattern uses an <b>interface</b> that concrete classes implement. In this Angular example, we use an <b>abstract class</b> (<code>NotificationAbstract</code>) instead, because it allows us to define common properties (like <code>message</code>) and optionally provide shared methods while still enforcing a contract for subclasses.",
      "step1": "<b>Step 1: Create Notification Framework</b><br>Define <code>NotificationAbstract</code> as a base for all notifications, declaring common methods like <code>show()</code>.",
      "step2": "<b>Step 2: Develop SuccessNotification</b><br>Create <code>NotificationSuccess</code> class, extending <code>NotificationAbstract</code>, and implement <code>show()</code> for success messages.",
      "step3": "<b>Step 3: Develop ErrorNotification</b><br>Create <code>NotificationError</code> class, extending <code>NotificationAbstract</code>, and implement <code>show()</code> for error messages.",
      "step4": "<b>Step 4: Develop WarningNotification</b><br>Create <code>NotificationWarning</code> class, extending <code>NotificationAbstract</code>, and implement <code>show()</code> for warning messages.",
      "step5": "<b>Step 5: Create NotificationFactory Service</b><br>Encapsulate creation logic depending on notification type in <code>NotificationFactoryService</code>.",
      "step6": "<b>Step 6: Use Factory Pattern in Component</b><br>Demonstrate the Factory Method pattern in <code>FactoryPatternComponent</code>, working only with abstractions."
    },
    "abstractFactory": {
      "title": "Abstract Factory",
      "description": "Abstract Factory is a <b>creational design pattern</b> that provides an interface for creating families of related objects without specifying their concrete classes.",
      "step1": "<b>Step 1: Define Abstract Button</b><br/>Create an abstract Button class declaring the render() method.",
      "step2": "<b>Step 2: Define Abstract Checkbox</b><br/>Create an abstract Checkbox class declaring the render() method.",
      "step3": "<b>Step 3: Implement LightButton</b><br/>Extend ButtonAbstract and implement the render() method for the light theme.",
      "step4": "<b>Step 4: Implement LightCheckbox</b><br/>Extend CheckboxAbstract and implement the render() method for the light theme.",
      "step5": "<b>Step 5: Implement DarkButton</b><br/>Extend ButtonAbstract and implement the render() method for the dark theme.",
      "step6": "<b>Step 6: Implement DarkCheckbox</b><br/>Extend CheckboxAbstract and implement the render() method for the dark theme.",
      "step7": "<b>Step 7: Define ThemeFactoryAbstract</b><br/>Declare methods to create Button and Checkbox.",
      "step8": "<b>Step 8: Implement LightFactory</b><br/>Produce LightButton and LightCheckbox.",
      "step9": "<b>Step 9: Implement DarkFactory</b><br/>Produce DarkButton and DarkCheckbox.",
      "step10": "<b>Step 10: Create AbstractFactoryService</b><br/>Provide a specific factory based on the selected theme.",
      "step11": "<b>Step 11: Build AbstractFactoryComponent</b><br/>Demonstrate creating UI elements from Light or Dark factories."
    },
    "builder": {
      "title": "Builder",
      "description": "<b>Builder</b> — creational design pattern that allows constructing complex objects step by step. Instead of passing all parameters into a constructor, Builder provides a fluent API for building objects gradually. <br><br>In classical implementations, Builder is often used for assembling objects like documents or configurations. In our Angular example, we use it to build a <b>UI card</b> step by step.",
      "step1": "<b>Step 1: Define Card Model</b><br>Create <code>Card</code> interface with optional properties: <code>title</code>, <code>description</code>, <code>image</code>, <code>button</code>.",
      "step2": "<b>Step 2: Define Abstract Builder</b><br>Create <code>CardBuilderAbstract</code> with methods for title, description, image, and button.",
      "step3": "<b>Step 3: Implement Concrete Builder</b><br>Implement <code>SimpleCardBuilder</code> that sets each property of the card.",
      "step4": "<b>Step 4: Add Director</b><br>Create <code>CardDirector</code> that builds a predefined card (e.g., product card).",
      "step5": "<b>Step 5: Use in Angular Component</b><br>Demonstrate card building in <code>BuilderPatternComponent</code>."
    },
    "prototype": {
      "title": "Prototype",
      "description": "<b>Prototype</b> — creational design pattern that lets you copy existing objects without making your code dependent on their concrete classes. It is especially useful when creating a new instance is costly or complex. <br><br>In this Angular example, we create and clone <b>user profiles</b> (Admin, Guest) using the <code>clone()</code> method.",
      "step1": "<b>Step 1: Define Prototype Base</b><br>Create <code>UserProfilePrototype</code> with the <code>clone()</code> method and common properties.",
      "step2": "<b>Step 2: Create AdminProfile</b><br>Extend <code>UserProfilePrototype</code> and implement the <code>clone()</code> method for admins.",
      "step3": "<b>Step 3: Create GuestProfile</b><br>Extend <code>UserProfilePrototype</code> and implement the <code>clone()</code> method for guests.",
      "step4": "<b>Step 4: Add Service</b><br>Use <code>UserProfileService</code> to create and clone profiles.",
      "step5": "<b>Step 5: Use in Component</b><br>Demonstrate creating and cloning profiles in <code>PrototypePatternComponent</code>."
    },
    "singleton": {
      "title": "Singleton",
      "description": "<b>Singleton</b> — creational design pattern that ensures a class has only one instance and provides a global point of access to it. <br><br>In this Angular example, we implement a <b>Logger</b> that keeps a single shared instance across the app.",
      "step1": "<b>Step 1: Create Singleton</b><br>Define <code>Logger</code> class with a private constructor and a static <code>getInstance()</code> method.",
      "step2": "<b>Step 2: Wrap with Service</b><br>Use <code>LoggerService</code> to interact with the singleton in Angular context.",
      "step3": "<b>Step 3: Use in Component</b><br>Demonstrate logging messages in <code>SingletonPatternComponent</code>, showing that all logs come from the same instance."
    }
  },
  "structural": {
    "adapter": {
      "title": "Adapter",
      "description": "<b>Adapter</b> — structural design pattern that allows incompatible interfaces to work together. In this Angular example, <code>LoggerAdapterService</code> makes a third-party logger (<code>ThirdPartyLogger</code>) compatible with our <code>Logger</code> interface.",
      "step1": "<b>Step 1: Define Target (Logger interface)</b><br>Create a <code>Logger</code> interface with <code>log()</code> and <code>error()</code> methods.",
      "step2": "<b>Step 2: Introduce Adaptee (ThirdPartyLogger)</b><br>Simulate a third-party logger with different method names (<code>writeInfo()</code>, <code>writeError()</code>).",
      "step3": "<b>Step 3: Implement Adapter (LoggerAdapterService)</b><br>Wrap <code>ThirdPartyLogger</code> so it conforms to <code>Logger</code> interface.",
      "step4": "<b>Step 4: Use Adapter in Component</b><br>Inject <code>LoggerAdapterService</code> into a component and log messages without depending on third-party API."
    },
    "bridge": {
      "title": "Bridge",
      "description": "<b>Bridge</b> — structural design pattern that decouples an abstraction from its implementation so the two can vary independently. <br><br>Use when you want to avoid a permanent binding between an abstraction and its implementation and be able to switch implementations at runtime.",
      "step1": "<b>Step 1: Define Implementor Interface</b><br>Create <code>MessageImplementor</code> interface that declares <code>showMessage(message: string)</code>.",
      "step2": "<b>Step 2: Implement ConsoleMessageService</b><br>Create <code>ConsoleMessageService</code> that implements <code>MessageImplementor</code> and writes messages to the console.",
      "step3": "<b>Step 3: Implement AlertMessageService</b><br>Create <code>AlertMessageService</code> that implements <code>MessageImplementor</code> and shows messages via <code>alert()</code> (or any UI mechanism).",
      "step4": "<b>Step 4: Define Abstraction (Message)</b><br>Create abstract <code>Message</code> class that holds a reference to <code>MessageImplementor</code> and declares <code>send(content: string)</code>.",
      "step5": "<b>Step 5: Implement Refined Abstraction</b><br>Implement <code>UserMessage</code> (or other concrete abstractions) that use the implementor to deliver messages.",
      "step6": "<b>Step 6: Use in Component</b><br>In <code>BridgeComponent</code> instantiate concrete implementor(s) and pass them into the abstraction to send messages (demonstrate switching implementations)."
    },
    "composite": {
      "title": "Composite",
      "description": "<b>Composite</b> — structural design pattern that lets you compose objects into tree structures and work with these structures as if they were individual objects. <br><br>This pattern is often used to represent part-whole hierarchies (e.g., UI elements, file system).",
      "step1": "<b>Step 1: Define Component interface</b><br>Create <code>Component</code> with <code>operation()</code>.",
      "step2": "<b>Step 2: Implement Leaf</b><br>Create <code>Leaf</code> class that implements <code>Component</code> and represents indivisible objects.",
      "step3": "<b>Step 3: Implement Composite</b><br>Create <code>Composite</code> class that stores children and implements <code>operation()</code> by delegating to them.",
      "step4": "<b>Step 4: Use in Component</b><br>Build a tree of <code>Leaf</code> and <code>Composite</code> objects and call <code>operation()</code>."
    },
    "decorator": {
      "title": "Decorator",
      "description": "<b>Decorator</b> — structural design pattern that allows you to dynamically add new behavior to objects by placing them inside special wrapper objects. <br><br>This makes it possible to extend functionality without modifying existing code.",
      "step1": "<b>Step 1: Define Notifier interface</b><br>Create <code>Notifier</code> with method <code>send(message: string)</code>.",
      "step2": "<b>Step 2: Implement BasicNotifier</b><br>Create class <code>BasicNotifier</code> as a simple implementation.",
      "step3": "<b>Step 3: Create NotifierDecorator</b><br>Abstract decorator that implements <code>Notifier</code> and wraps another notifier.",
      "step4": "<b>Step 4: Implement SmsNotifier</b><br>Concrete decorator that adds SMS sending functionality.",
      "step5": "<b>Step 5: Implement EmailNotifier</b><br>Concrete decorator that adds Email sending functionality.",
      "step6": "<b>Step 6: Use in Component</b><br>Wrap notifiers and demonstrate extended functionality in <code>DecoratorComponent</code>."
    },
    "facade": {
      "title": "Facade",
      "description": "<b>Facade</b> — structural design pattern that provides a simplified interface to a complex subsystem. <br><br>It hides the complexity of multiple classes and exposes only what is necessary for the client.",
      "step1": "<b>Step 1: Create VideoPlayer</b><br>Class <code>VideoPlayer</code> handles video playback.",
      "step2": "<b>Step 2: Create AudioPlayer</b><br>Class <code>AudioPlayer</code> handles audio playback.",
      "step3": "<b>Step 3: Create Subtitles</b><br>Class <code>Subtitles</code> loads subtitle files.",
      "step4": "<b>Step 4: Implement MediaFacade</b><br>Encapsulate video, audio, and subtitles into <code>MediaFacade</code> with a simple <code>playMovie()</code> method.",
      "step5": "<b>Step 5: Use in Component</b><br>Demonstrate usage of <code>MediaFacade</code> in <code>FacadeComponent</code>."
    },
    "flyweight": {
      "title": "Flyweight",
      "description": "<b>Flyweight</b> — structural design pattern that minimizes memory usage by sharing common parts of objects instead of duplicating them. <br><br>It is useful when working with a large number of similar objects.",
      "step1": "<b>Step 1: Create Character class</b><br>Class <code>Character</code> stores intrinsic data (symbol, font) and provides a <code>display()</code> method.",
      "step2": "<b>Step 2: Implement CharacterFactory</b><br>Factory ensures that characters with the same symbol and font are reused instead of being recreated.",
      "step3": "<b>Step 3: Use in Component</b><br>Demonstrate <code>Flyweight</code> in <code>FlyweightComponent</code> by rendering text with shared characters."
    },
    "proxy": {
      "title": "Proxy",
      "description": "<b>Proxy</b> — structural design pattern that provides a substitute or placeholder for another object to control access to it. <br><br>Proxy is often used for caching, lazy initialization, or access control.",
      "step1": "<b>Step 1: Define VideoService interface</b><br>Declares the common interface for Real and Proxy services.",
      "step2": "<b>Step 2: Create RealVideoService</b><br>Implements actual video playback.",
      "step3": "<b>Step 3: Implement VideoServiceProxy</b><br>Adds caching functionality and delegates playback to RealVideoService when needed.",
      "step4": "<b>Step 4: Use in Component</b><br>Demonstrates caching when the same video is played multiple times."
    }
  },
  "behavioral": {
    "chainOfResponsibility": {
      "title": "Chain of Responsibility",
      "description": "<b>Chain of Responsibility</b> — behavioral design pattern that lets you pass requests along a chain of handlers. Each handler decides either to process the request or pass it to the next handler in the chain.",
      "step1": "<b>Step 1: Define Handler interface</b><br>Declares methods for setting the next handler and processing a request.",
      "step2": "<b>Step 2: Create BaseHandler</b><br>Implements default chaining behavior.",
      "step3": "<b>Step 3: Implement Concrete Handlers</b><br>AuthHandler, LoggingHandler, and DataHandler handle different requests.",
      "step4": "<b>Step 4: Use in Component</b><br>Demonstrates request processing through the chain."
    }
  }
}
