{
  "creational": {
    "factory": {
      "title": "Фабричний метод",
      "description": "<b>Фабричний метод</b> — шаблон проектування, що визначає загальний інтерфейс для створення об'єктів, дозволяючи підкласам вирішувати, який клас інстанціювати. Працює з абстракціями замість конкретних класів, спрощує розширення та обслуговування. <br><br>У класичній реалізації патерн використовує <b>інтерфейс</b>, який імплементують конкретні класи. У нашому прикладі на Angular ми використовуємо <b>абстрактний клас</b> (<code>NotificationAbstract</code>), оскільки він дозволяє визначати спільні властивості (наприклад, <code>message</code>) та при потребі надавати спільні методи, одночасно зберігаючи контракт для підкласів.",
      "step1": "<b>Крок 1: Створити Notification Framework</b><br>Визначити <code>NotificationAbstract</code> як базу для всіх повідомлень, оголосити спільні методи, такі як <code>show()</code>.",
      "step2": "<b>Крок 2: Реалізувати SuccessNotification</b><br>Створити клас <code>NotificationSuccess</code>, що розширює <code>NotificationAbstract</code>, та реалізувати <code>show()</code> для повідомлень про успіх.",
      "step3": "<b>Крок 3: Реалізувати ErrorNotification</b><br>Створити клас <code>NotificationError</code>, що розширює <code>NotificationAbstract</code>, та реалізувати <code>show()</code> для повідомлень про помилку.",
      "step4": "<b>Крок 4: Реалізувати WarningNotification</b><br>Створити клас <code>NotificationWarning</code>, що розширює <code>NotificationAbstract</code>, та реалізувати <code>show()</code> для повідомлень-попереджень.",
      "step5": "<b>Крок 5: Створити сервіс NotificationFactory</b><br>Інкапсулювати логіку створення об’єктів залежно від типу повідомлення у <code>NotificationFactoryService</code>.",
      "step6": "<b>Крок 6: Використати патерн у компоненті</b><br>Продемонструвати використання патерну Factory Method у <code>FactoryPatternComponent</code>, працюючи лише з абстракціями."
    },
    "abstractFactory": {
      "title": "Абстрактна фабрика",
      "description": "Абстрактна фабрика — це <b>шаблон проєктування</b>, що надає інтерфейс для створення цілих сімейств пов'язаних об'єктів без вказівки їх конкретних класів.",
      "step1": "<b>Крок 1: Створіть абстрактний Button</b><br/>Оголосіть абстрактний клас Button з методом render().",
      "step2": "<b>Крок 2: Створіть абстрактний Checkbox</b><br/>Оголосіть абстрактний клас Checkbox з методом render().",
      "step3": "<b>Крок 3: Реалізуйте LightButton</b><br/>Наслідуйте ButtonAbstract і реалізуйте метод render() для світлої теми.",
      "step4": "<b>Крок 4: Реалізуйте LightCheckbox</b><br/>Наслідуйте CheckboxAbstract і реалізуйте метод render() для світлої теми.",
      "step5": "<b>Крок 5: Реалізуйте DarkButton</b><br/>Наслідуйте ButtonAbstract і реалізуйте метод render() для темної теми.",
      "step6": "<b>Крок 6: Реалізуйте DarkCheckbox</b><br/>Наслідуйте CheckboxAbstract і реалізуйте метод render() для темної теми.",
      "step7": "<b>Крок 7: Створіть ThemeFactoryAbstract</b><br/>Оголосіть методи для створення Button та Checkbox.",
      "step8": "<b>Крок 8: Реалізуйте LightFactory</b><br/>Забезпечує створення LightButton та LightCheckbox.",
      "step9": "<b>Крок 9: Реалізуйте DarkFactory</b><br/>Забезпечує створення DarkButton та DarkCheckbox.",
      "step10": "<b>Крок 10: Створіть AbstractFactoryService</b><br/>Надає конкретну фабрику залежно від вибраної теми.",
      "step11": "<b>Крок 11: Створіть AbstractFactoryComponent</b><br/>Демонструє створення UI-елементів зі світлої та темної фабрики."
    },
    "builder": {
      "title": "Будівельник",
      "description": "<b>Будівельник</b> — породжувальний шаблон проєктування, який дозволяє поетапно створювати складні об’єкти. Замість передачі всіх параметрів у конструктор, Builder надає зручний API для поступового збирання об’єкта. <br><br>У класичних реалізаціях його часто використовують для створення документів або конфігурацій. У нашому прикладі на Angular ми використовуємо його для побудови <b>UI-картки</b> крок за кроком.",
      "step1": "<b>Крок 1: Визначити модель Card</b><br>Створити інтерфейс <code>Card</code> з необов’язковими властивостями: <code>title</code>, <code>description</code>, <code>image</code>, <code>button</code>.",
      "step2": "<b>Крок 2: Визначити абстрактного будівельника</b><br>Створити <code>CardBuilderAbstract</code> з методами для заголовка, опису, зображення та кнопки.",
      "step3": "<b>Крок 3: Реалізувати конкретного будівельника</b><br>Реалізувати <code>SimpleCardBuilder</code>, який задає всі властивості картки.",
      "step4": "<b>Крок 4: Додати директора</b><br>Створити <code>CardDirector</code>, який збирає заздалегідь визначену картку (наприклад, картку продукту).",
      "step5": "<b>Крок 5: Використати в Angular компоненті</b><br>Продемонструвати побудову картки у <code>BuilderPatternComponent</code>."
    },
    "prototype": {
      "title": "Прототип",
      "description": "<b>Прототип</b> — породжувальний шаблон проєктування, який дозволяє копіювати вже існуючі об’єкти без прив’язки до їхніх конкретних класів. Особливо корисний, коли створення нового екземпляра є витратним або складним. <br><br>У цьому прикладі на Angular ми створюємо та клонуємо <b>користувацькі профілі</b> (Admin, Guest), використовуючи метод <code>clone()</code>.",
      "step1": "<b>Крок 1: Визначити базовий Прототип</b><br>Створити <code>UserProfilePrototype</code> з методом <code>clone()</code> та спільними властивостями.",
      "step2": "<b>Крок 2: Створити AdminProfile</b><br>Розширити <code>UserProfilePrototype</code> і реалізувати метод <code>clone()</code> для адміністраторів.",
      "step3": "<b>Крок 3: Створити GuestProfile</b><br>Розширити <code>UserProfilePrototype</code> і реалізувати метод <code>clone()</code> для гостей.",
      "step4": "<b>Крок 4: Додати сервіс</b><br>Використати <code>UserProfileService</code> для створення та клонування профілів.",
      "step5": "<b>Крок 5: Використати у компоненті</b><br>Продемонструвати створення та клонування профілів у <code>PrototypePatternComponent</code>."
    },
    "singleton": {
      "title": "Одинак",
      "description": "<b>Одинак</b> — породжувальний шаблон проєктування, який гарантує, що клас має лише один екземпляр і надає глобальну точку доступу до нього. <br><br>У цьому прикладі на Angular ми реалізуємо <b>Logger</b>, що зберігає єдиний спільний екземпляр у всьому застосунку.",
      "step1": "<b>Крок 1: Створити Singleton</b><br>Визначити клас <code>Logger</code> із приватним конструктором та статичним методом <code>getInstance()</code>.",
      "step2": "<b>Крок 2: Обгорнути у сервіс</b><br>Використати <code>LoggerService</code> для роботи з сінглтоном у контексті Angular.",
      "step3": "<b>Крок 3: Використати у компоненті</b><br>Продемонструвати логування повідомлень у <code>SingletonPatternComponent</code>, показавши, що всі логи походять з одного екземпляра."
    }
  },
  "structural": {
    "adapter": {
      "title": "Адаптер",
      "description": "<b>Адаптер</b> — структурний шаблон проектування, який дозволяє працювати разом об’єктам із несумісними інтерфейсами. У цьому прикладі на Angular <code>LoggerAdapterService</code> робить сторонній логер (<code>ThirdPartyLogger</code>) сумісним із нашим інтерфейсом <code>Logger</code>.",
      "step1": "<b>Крок 1: Визначити Target (Logger interface)</b><br>Створити інтерфейс <code>Logger</code> із методами <code>log()</code> та <code>error()</code>.",
      "step2": "<b>Крок 2: Додати Adaptee (ThirdPartyLogger)</b><br>Імітувати сторонній логер із методами <code>writeInfo()</code> та <code>writeError()</code>.",
      "step3": "<b>Крок 3: Реалізувати Adapter (LoggerAdapterService)</b><br>Обгорнути <code>ThirdPartyLogger</code>, щоб він відповідав інтерфейсу <code>Logger</code>.",
      "step4": "<b>Крок 4: Використати Adapter у компоненті</b><br>Інжектити <code>LoggerAdapterService</code> у компонент і логувати повідомлення без залежності від стороннього API."
    },
    "bridge": {
      "title": "Міст (Bridge)",
      "description": "<b>Міст</b> — структурний шаблон проектування, що розділяє абстракцію та її реалізацію, дозволяючи їм змінюватися незалежно. <br><br>Використовується, коли потрібно уникнути жорсткого зв’язку між абстракцією та реалізацією і мати можливість підміняти реалізації під час виконання.",
      "step1": "<b>Крок 1: Визначити інтерфейс реалізації</b><br>Створити <code>MessageImplementor</code> із методом <code>showMessage(message: string)</code>.",
      "step2": "<b>Крок 2: Реалізувати ConsoleMessageService</b><br>Створити <code>ConsoleMessageService</code>, який реалізує <code>MessageImplementor</code> і виводить повідомлення в консоль.",
      "step3": "<b>Крок 3: Реалізувати AlertMessageService</b><br>Створити <code>AlertMessageService</code>, який реалізує <code>MessageImplementor</code> і показує повідомлення через <code>alert()</code> (або інший UI-канал).",
      "step4": "<b>Крок 4: Визначити абстракцію (Message)</b><br>Створити абстрактний клас <code>Message</code>, що тримає посилання на <code>MessageImplementor</code> та декларує метод <code>send(content: string)</code>.",
      "step5": "<b>Крок 5: Реалізувати уточнену абстракцію</b><br>Реалізувати <code>UserMessage</code> (або інші конкретні абстракції), які використовують реалізатор для доставки повідомлень.",
      "step6": "<b>Крок 6: Використати у компоненті</b><br>У <code>BridgeComponent</code> інстанціювати конкретні реалізації та передавати їх у абстракцію, щоб надіслати повідомлення (показати підміну реалізації)."
    },
    "composite": {
      "title": "Компонувальник (Composite)",
      "description": "<b>Компонувальник</b> — структурний шаблон проектування, який дозволяє об’єднувати об’єкти в деревоподібні структури та працювати з ними так, ніби це окремі об’єкти. <br><br>Часто використовується для представлення ієрархій «частина-ціле» (наприклад, елементи інтерфейсу, файлові системи).",
      "step1": "<b>Крок 1: Визначити інтерфейс Component</b><br>Створити <code>Component</code> з методом <code>operation()</code>.",
      "step2": "<b>Крок 2: Реалізувати Leaf</b><br>Створити клас <code>Leaf</code>, який реалізує <code>Component</code> і представляє неподільні об’єкти.",
      "step3": "<b>Крок 3: Реалізувати Composite</b><br>Створити клас <code>Composite</code>, що зберігає дітей і реалізує <code>operation()</code>, делегуючи виклик їм.",
      "step4": "<b>Крок 4: Використати у компоненті</b><br>Побудувати дерево з об’єктів <code>Leaf</code> та <code>Composite</code> і викликати <code>operation()</code>."
    },
    "decorator": {
      "title": "Декоратор",
      "description": "<b>Декоратор</b> — структурний шаблон проектування, який дозволяє динамічно додавати нову поведінку об’єктам, обгортаючи їх у спеціальні об’єкти-«обгортки». <br><br>Це дає можливість розширювати функціонал без зміни існуючого коду.",
      "step1": "<b>Крок 1: Визначити інтерфейс Notifier</b><br>Створити <code>Notifier</code> з методом <code>send(message: string)</code>.",
      "step2": "<b>Крок 2: Реалізувати BasicNotifier</b><br>Створити клас <code>BasicNotifier</code> як просту реалізацію.",
      "step3": "<b>Крок 3: Створити NotifierDecorator</b><br>Абстрактний декоратор, що реалізує <code>Notifier</code> та обгортає інший notifier.",
      "step4": "<b>Крок 4: Реалізувати SmsNotifier</b><br>Конкретний декоратор, що додає можливість відправки SMS.",
      "step5": "<b>Крок 5: Реалізувати EmailNotifier</b><br>Конкретний декоратор, що додає можливість відправки Email.",
      "step6": "<b>Крок 6: Використати у компоненті</b><br>Обгорнути notifier-и та продемонструвати розширену функціональність у <code>DecoratorComponent</code>."
    },
    "facade": {
      "title": "Фасад",
      "description": "<b>Фасад</b> — структурний шаблон проектування, що надає спрощений інтерфейс до складної підсистеми. <br><br>Він приховує складність взаємодії багатьох класів і відкриває лише необхідний функціонал для клієнта.",
      "step1": "<b>Крок 1: Створити VideoPlayer</b><br>Клас <code>VideoPlayer</code> відповідає за відтворення відео.",
      "step2": "<b>Крок 2: Створити AudioPlayer</b><br>Клас <code>AudioPlayer</code> відповідає за відтворення аудіо.",
      "step3": "<b>Крок 3: Створити Subtitles</b><br>Клас <code>Subtitles</code> завантажує файли субтитрів.",
      "step4": "<b>Крок 4: Реалізувати MediaFacade</b><br>Інкапсулювати роботу з відео, аудіо та субтитрами у класі <code>MediaFacade</code> з простим методом <code>playMovie()</code>.",
      "step5": "<b>Крок 5: Використати у компоненті</b><br>Продемонструвати використання <code>MediaFacade</code> у <code>FacadeComponent</code>."
    },
    "flyweight": {
      "title": "Легковаговик",
      "description": "<b>Легковаговик</b> — структурний шаблон проектування, що мінімізує використання пам’яті шляхом спільного використання спільних частин об’єктів замість їх дублювання. <br><br>Корисний під час роботи з великою кількістю подібних об’єктів.",
      "step1": "<b>Крок 1: Створити клас Character</b><br>Клас <code>Character</code> зберігає внутрішні дані (символ, шрифт) і надає метод <code>display()</code>.",
      "step2": "<b>Крок 2: Реалізувати CharacterFactory</b><br>Фабрика гарантує, що символи з однаковим символом і шрифтом повторно використовуються, а не створюються заново.",
      "step3": "<b>Крок 3: Використати у компоненті</b><br>Продемонструвати <code>Flyweight</code> у <code>FlyweightComponent</code>, відображаючи текст зі спільними символами."
    },
    "proxy": {
      "title": "Проксі",
      "description": "<b>Проксі</b> — структурний шаблон проектування, що надає замінник або посередника для іншого об’єкта з метою контролю доступу до нього. <br><br>Часто використовується для кешування, лінивої ініціалізації або контролю доступу.",
      "step1": "<b>Крок 1: Створити інтерфейс VideoService</b><br>Визначає спільний інтерфейс для Реального сервісу та Проксі.",
      "step2": "<b>Крок 2: Реалізувати RealVideoService</b><br>Виконує фактичне відтворення відео.",
      "step3": "<b>Крок 3: Реалізувати VideoServiceProxy</b><br>Додає функціонал кешування та делегує відтворення до RealVideoService за потреби.",
      "step4": "<b>Крок 4: Використати у компоненті</b><br>Демонструє кешування при повторному відтворенні одного й того ж відео."
    }
  },
  "behavioral": {
    "chainOfResponsibility": {
      "title": "Ланцюг обов’язків",
      "description": "<b>Ланцюг обов’язків</b> — поведінковий шаблон проектування, що дозволяє передавати запити вздовж ланцюга обробників. Кожен обробник вирішує, чи обробити запит, чи передати далі.",
      "step1": "<b>Крок 1: Визначити інтерфейс Handler</b><br>Оголошує методи для встановлення наступного обробника та обробки запиту.",
      "step2": "<b>Крок 2: Створити BaseHandler</b><br>Реалізує стандартну поведінку передавання запиту.",
      "step3": "<b>Крок 3: Реалізувати конкретні обробники</b><br>AuthHandler, LoggingHandler та DataHandler обробляють різні типи запитів.",
      "step4": "<b>Крок 4: Використати у компоненті</b><br>Демонструє передавання запиту через ланцюг."
    },
    "command": {
      "title": "Команда",
      "description": "<b>Команда</b> — поведінковий шаблон проектування, що перетворює запит у самостійний об’єкт, який містить усю інформацію про запит. Це дозволяє параметризувати об’єкти операціями, відкладати виконання та підтримувати скасування/повтор.",
      "step1": "<b>Крок 1: Визначити інтерфейс Command</b><br>Оголошує метод <code>execute()</code>.",
      "step2": "<b>Крок 2: Створити конкретні команди</b><br>TurnOnLightCommand та TurnOffLightCommand інкапсулюють дії для Light.",
      "step3": "<b>Крок 3: Реалізувати Invoker</b><br>RemoteControl зберігає команди та виконує їх за потреби.",
      "step4": "<b>Крок 4: Використати у компоненті</b><br>Демонструє постановку в чергу та виконання команд через RemoteControl."
    },
    "iterator": {
      "title": "Ітератор",
      "description": "<b>Ітератор</b> — поведінковий шаблон проектування, що надає спосіб послідовного доступу до елементів колекції без розкриття її внутрішньої структури.",
      "step1": "<b>Крок 1: Визначити інтерфейс Iterator</b><br>Оголошує методи <code>next()</code> та <code>hasNext()</code>.",
      "step2": "<b>Крок 2: Реалізувати конкретний ітератор</b><br>Створити <code>NameIterator</code> та <code>NameCollection</code> для управління логікою ітерації.",
      "step3": "<b>Крок 3: Використати ітератор у компоненті</b><br>Перебрати колекцію імен та відобразити їх в UI."
    },
    "mediator": {
      "title": "Посередник",
      "description": "<b>Посередник</b> — поведінковий шаблон проектування, що визначає об’єкт, який інкапсулює взаємодію між кількома об’єктами, запобігаючи їх прямим посиланням один на одного та сприяючи слабкому зв’язуванню.",
      "step1": "<b>Крок 1: Визначити інтерфейс Mediator</b><br>Оголосити методи для відправки повідомлень та додавання користувачів.",
      "step2": "<b>Крок 2: Реалізувати конкретного посередника</b><br>Створити <code>ChatMediatorService</code> для управління комунікацією між користувачами.",
      "step3": "<b>Крок 3: Створити клас користувача</b><br>Реалізувати <code>ChatUser</code>, який взаємодіє через посередника замість прямих посилань.",
      "step4": "<b>Крок 4: Використати посередника у компоненті</b><br>Продемонструвати чат, де користувачі обмінюються повідомленнями через посередника."
    },
    "memento": {
      "title": "Сувенір (Знімок)",
      "description": "<b>Сувенір</b> — поведінковий шаблон проєктування, що дозволяє зберігати та відновлювати попередній стан об’єкта, не розкриваючи деталей його реалізації.",
      "step1": "<b>Крок 1: Створити клас Memento</b><br>Інкапсулює стан об’єкта Originator.",
      "step2": "<b>Крок 2: Реалізувати Originator</b><br>Зберігає внутрішній стан і створює/відновлює знімки.",
      "step3": "<b>Крок 3: Реалізувати Caretaker</b><br>Керує знімками та отримує їх у потрібний момент.",
      "step4": "<b>Крок 4: Використати у компоненті</b><br>Зберегти кілька станів та відновити їх для демонстрації відкату."
    },
    "observer": {
      "title": "Спостерігач",
      "description": "<b>Спостерігач</b> — поведінковий шаблон проєктування, що визначає залежність «один-до-багатьох» між об’єктами, щоб при зміні стану одного об’єкта всі залежні автоматично отримували повідомлення.",
      "step1": "<b>Крок 1: Визначити інтерфейс Observer</b><br>Оголошує метод <code>update()</code> для отримання змін стану.",
      "step2": "<b>Крок 2: Реалізувати Subject</b><br>Керує списком спостерігачів та сповіщає їх про зміни.",
      "step3": "<b>Крок 3: Створити ConcreteObserver</b><br>Реалізує метод <code>update()</code>, щоб реагувати на зміни стану.",
      "step4": "<b>Крок 4: Використати патерн у компоненті</b><br>Створити кілька спостерігачів, підписати їх на Subject та продемонструвати оновлення."
    },
    "state": {
      "title": "Стан",
      "description": "<b>Стан</b> — поведінковий шаблон проєктування, що дозволяє об’єкту змінювати свою поведінку при зміні його внутрішнього стану. Здається, ніби об’єкт змінює свій клас.",
      "step1": "<b>Крок 1: Визначити інтерфейс State</b><br>Оголошує метод <code>handle()</code> для представлення поведінки у різних станах.",
      "step2": "<b>Крок 2: Реалізувати конкретні стани</b><br>Створити <code>PlayingState</code>, <code>PausedState</code> та <code>StoppedState</code> для визначення специфічної поведінки.",
      "step3": "<b>Крок 3: Реалізувати Context</b><br>Зберігає посилання на поточний стан і делегує йому поведінку.",
      "step4": "<b>Крок 4: Використати патерн у компоненті</b><br>Динамічно перемикатися між станами (відтворення, пауза, зупинка)."
    }
  }
}
