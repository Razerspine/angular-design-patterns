{
  "creational": {
    "factory": {
      "title": "Factory Method",
      "description": "<b>Factory Method</b> — creational design pattern that defines a common interface for creating objects, allowing subclasses to decide which class to instantiate. Works with abstractions instead of concrete classes, simplifies extension and maintenance. <br><br>In the classical implementation, the pattern uses an <b>interface</b> that concrete classes implement. In this Angular example, we use an <b>abstract class</b> (<code>NotificationAbstract</code>) instead, because it allows us to define common properties (like <code>message</code>) and optionally provide shared methods while still enforcing a contract for subclasses.",
      "step1": "<b>Step 1: Create Notification Framework</b><br>Define <code>NotificationAbstract</code> as a base for all notifications, declaring common methods like <code>show()</code>.",
      "step2": "<b>Step 2: Develop SuccessNotification</b><br>Create <code>NotificationSuccess</code> class, extending <code>NotificationAbstract</code>, and implement <code>show()</code> for success messages.",
      "step3": "<b>Step 3: Develop ErrorNotification</b><br>Create <code>NotificationError</code> class, extending <code>NotificationAbstract</code>, and implement <code>show()</code> for error messages.",
      "step4": "<b>Step 4: Develop WarningNotification</b><br>Create <code>NotificationWarning</code> class, extending <code>NotificationAbstract</code>, and implement <code>show()</code> for warning messages.",
      "step5": "<b>Step 5: Create NotificationFactory Service</b><br>Encapsulate creation logic depending on notification type in <code>NotificationFactoryService</code>.",
      "step6": "<b>Step 6: Use Factory Pattern in Component</b><br>Demonstrate the Factory Method pattern in <code>FactoryPatternComponent</code>, working only with abstractions."
    },
    "abstractFactory": {
      "title": "Abstract Factory",
      "description": "Abstract Factory is a <b>creational design pattern</b> that provides an interface for creating families of related objects without specifying their concrete classes.",
      "step1": "<b>Step 1: Define Abstract Button</b><br/>Create an abstract Button class declaring the render() method.",
      "step2": "<b>Step 2: Define Abstract Checkbox</b><br/>Create an abstract Checkbox class declaring the render() method.",
      "step3": "<b>Step 3: Implement LightButton</b><br/>Extend ButtonAbstract and implement the render() method for the light theme.",
      "step4": "<b>Step 4: Implement LightCheckbox</b><br/>Extend CheckboxAbstract and implement the render() method for the light theme.",
      "step5": "<b>Step 5: Implement DarkButton</b><br/>Extend ButtonAbstract and implement the render() method for the dark theme.",
      "step6": "<b>Step 6: Implement DarkCheckbox</b><br/>Extend CheckboxAbstract and implement the render() method for the dark theme.",
      "step7": "<b>Step 7: Define ThemeFactoryAbstract</b><br/>Declare methods to create Button and Checkbox.",
      "step8": "<b>Step 8: Implement LightFactory</b><br/>Produce LightButton and LightCheckbox.",
      "step9": "<b>Step 9: Implement DarkFactory</b><br/>Produce DarkButton and DarkCheckbox.",
      "step10": "<b>Step 10: Create AbstractFactoryService</b><br/>Provide a specific factory based on the selected theme.",
      "step11": "<b>Step 11: Build AbstractFactoryComponent</b><br/>Demonstrate creating UI elements from Light or Dark factories."
    },
    "builder": {
      "title": "Builder",
      "description": "<b>Builder</b> — creational design pattern that allows constructing complex objects step by step. Instead of passing all parameters into a constructor, Builder provides a fluent API for building objects gradually. <br><br>In classical implementations, Builder is often used for assembling objects like documents or configurations. In our Angular example, we use it to build a <b>UI card</b> step by step.",
      "step1": "<b>Step 1: Define Card Model</b><br>Create <code>Card</code> interface with optional properties: <code>title</code>, <code>description</code>, <code>image</code>, <code>button</code>.",
      "step2": "<b>Step 2: Define Abstract Builder</b><br>Create <code>CardBuilderAbstract</code> with methods for title, description, image, and button.",
      "step3": "<b>Step 3: Implement Concrete Builder</b><br>Implement <code>SimpleCardBuilder</code> that sets each property of the card.",
      "step4": "<b>Step 4: Add Director</b><br>Create <code>CardDirector</code> that builds a predefined card (e.g., product card).",
      "step5": "<b>Step 5: Use in Angular Component</b><br>Demonstrate card building in <code>BuilderPatternComponent</code>."
    }
  }
}
